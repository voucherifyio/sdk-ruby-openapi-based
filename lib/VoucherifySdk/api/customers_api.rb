=begin
#Voucherify API

#Voucherify promotion engine REST API. Please see https://docs.voucherify.io/docs for more details.

The version of the OpenAPI document: v2018-08-01
Contact: support@voucherify.io
Generated by: https://openapi-generator.tech
OpenAPI Generator version: 7.0.1

=end

require 'cgi'

module VoucherifySdk
  class CustomersApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Create Customer
    # Creates a customer object.    > ðŸ“˜ Upsert Mode > > If you pass an `id` or a `source_id` that already exists in the customer database, Voucherify will return a related customer object with updated fields.
    # @param [Hash] opts the optional parameters
    # @option opts [CustomersCreateRequestBody] :customers_create_request_body Create a customer with specified parameters.
    # @return [CustomersCreateResponseBody]
    def create_customer(opts = {})
      data, _status_code, _headers = create_customer_with_http_info(opts)
      data
    end

    # Create Customer
    # Creates a customer object.    &gt; ðŸ“˜ Upsert Mode &gt; &gt; If you pass an &#x60;id&#x60; or a &#x60;source_id&#x60; that already exists in the customer database, Voucherify will return a related customer object with updated fields.
    # @param [Hash] opts the optional parameters
    # @option opts [CustomersCreateRequestBody] :customers_create_request_body Create a customer with specified parameters.
    # @return [Array<(CustomersCreateResponseBody, Integer, Hash)>] CustomersCreateResponseBody data, response status code and response headers
    private def create_customer_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CustomersApi.create_customer ...'
      end
      # resource path
      local_var_path = '/v1/customers'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'customers_create_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'CustomersCreateResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-App-Id', 'X-App-Token']

      new_options = opts.merge(
        :operation => :"CustomersApi.create_customer",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CustomersApi#create_customer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Customer Permanently
    # The organization user can remove consumer data permanently from the Voucherify system by using this API method. It dâ€‹eletes all customer data and connected resources. It makes the customer profile forgotten by Voucherify.
    # @param customer_id [String] A Voucherify customer&#39;s &#x60;id&#x60; or &#x60;source_id&#x60;.
    # @param [Hash] opts the optional parameters
    # @return [CustomersPermanentDeletionCreateResponseBody]
    def customer_permanently_deletion(customer_id, opts = {})
      data, _status_code, _headers = customer_permanently_deletion_with_http_info(customer_id, opts)
      data
    end

    # Delete Customer Permanently
    # The organization user can remove consumer data permanently from the Voucherify system by using this API method. It dâ€‹eletes all customer data and connected resources. It makes the customer profile forgotten by Voucherify.
    # @param customer_id [String] A Voucherify customer&#39;s &#x60;id&#x60; or &#x60;source_id&#x60;.
    # @param [Hash] opts the optional parameters
    # @return [Array<(CustomersPermanentDeletionCreateResponseBody, Integer, Hash)>] CustomersPermanentDeletionCreateResponseBody data, response status code and response headers
    private def customer_permanently_deletion_with_http_info(customer_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CustomersApi.customer_permanently_deletion ...'
      end
      # verify the required parameter 'customer_id' is set
      if @api_client.config.client_side_validation && customer_id.nil?
        fail ArgumentError, "Missing the required parameter 'customer_id' when calling CustomersApi.customer_permanently_deletion"
      end
      # resource path
      local_var_path = '/v1/customers/{customerId}/permanent-deletion'.sub('{' + 'customerId' + '}', CGI.escape(customer_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CustomersPermanentDeletionCreateResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-App-Id', 'X-App-Token']

      new_options = opts.merge(
        :operation => :"CustomersApi.customer_permanently_deletion",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CustomersApi#customer_permanently_deletion\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Customer
    # This method deletes a customer.
    # @param customer_id [String] A Voucherify customer&#39;s &#x60;id&#x60; or &#x60;source_id&#x60;.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_customer(customer_id, opts = {})
      delete_customer_with_http_info(customer_id, opts)
      nil
    end

    # Delete Customer
    # This method deletes a customer.
    # @param customer_id [String] A Voucherify customer&#39;s &#x60;id&#x60; or &#x60;source_id&#x60;.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    private def delete_customer_with_http_info(customer_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CustomersApi.delete_customer ...'
      end
      # verify the required parameter 'customer_id' is set
      if @api_client.config.client_side_validation && customer_id.nil?
        fail ArgumentError, "Missing the required parameter 'customer_id' when calling CustomersApi.delete_customer"
      end
      # resource path
      local_var_path = '/v1/customers/{customerId}'.sub('{' + 'customerId' + '}', CGI.escape(customer_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-App-Id', 'X-App-Token']

      new_options = opts.merge(
        :operation => :"CustomersApi.delete_customer",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CustomersApi#delete_customer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Customer
    # Retrieve customer details.
    # @param customer_id [String] A Voucherify customer&#39;s &#x60;id&#x60; or &#x60;source_id&#x60;.
    # @param [Hash] opts the optional parameters
    # @return [CustomersGetResponseBody]
    def get_customer(customer_id, opts = {})
      data, _status_code, _headers = get_customer_with_http_info(customer_id, opts)
      data
    end

    # Get Customer
    # Retrieve customer details.
    # @param customer_id [String] A Voucherify customer&#39;s &#x60;id&#x60; or &#x60;source_id&#x60;.
    # @param [Hash] opts the optional parameters
    # @return [Array<(CustomersGetResponseBody, Integer, Hash)>] CustomersGetResponseBody data, response status code and response headers
    private def get_customer_with_http_info(customer_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CustomersApi.get_customer ...'
      end
      # verify the required parameter 'customer_id' is set
      if @api_client.config.client_side_validation && customer_id.nil?
        fail ArgumentError, "Missing the required parameter 'customer_id' when calling CustomersApi.get_customer"
      end
      # resource path
      local_var_path = '/v1/customers/{customerId}'.sub('{' + 'customerId' + '}', CGI.escape(customer_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CustomersGetResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-App-Id', 'X-App-Token']

      new_options = opts.merge(
        :operation => :"CustomersApi.get_customer",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CustomersApi#get_customer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Import and Update Customers using CSV
    # This API method lets you import or update customer data. To get a proper and valid response, please send a CSV file with data separated by commas.    ## Request Example  ```cURL curl -X POST \\   https://api.voucherify.io/v1/customers/importCSV \\   -F file=@/path/to/customers.csv \\   -H \"X-App-Id: c70a6f00-cf91-4756-9df5-47628850002b\" \\   -H \"X-App-Token: 3266b9f8-e246-4f79-bdf0-833929b1380c\" ``` ## CSV File Format  The CSV file has to include headers in the first line. All properties which cannot be mapped to standard customer fields will be added to the metadata object.   > ðŸ“˜ Standard customer fields mapping > > **No spaces allowed in field names**   > Id, Name, Email, Phone, Birthdate, Source_id, Address_line_1, Address_line_2, Address_Postal_Code, Address_City, Address_State, Address_Country, Description, Metadata_name_1, Metadata_name_2  ## Update Customers using CSV  If you would like to update customer's data, you can do it using the CSV file with new data. However, remember to include a `source_id` in your CSV file to manage the update successfully.  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the `IN_PROGRESS` status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
    # @param file [File] File path.
    # @param [Hash] opts the optional parameters
    # @return [CustomersImportCsvCreateResponseBody]
    def import_customers_using_csv(file, opts = {})
      data, _status_code, _headers = import_customers_using_csv_with_http_info(file, opts)
      data
    end

    # Import and Update Customers using CSV
    # This API method lets you import or update customer data. To get a proper and valid response, please send a CSV file with data separated by commas.    ## Request Example  &#x60;&#x60;&#x60;cURL curl -X POST \\   https://api.voucherify.io/v1/customers/importCSV \\   -F file&#x3D;@/path/to/customers.csv \\   -H \&quot;X-App-Id: c70a6f00-cf91-4756-9df5-47628850002b\&quot; \\   -H \&quot;X-App-Token: 3266b9f8-e246-4f79-bdf0-833929b1380c\&quot; &#x60;&#x60;&#x60; ## CSV File Format  The CSV file has to include headers in the first line. All properties which cannot be mapped to standard customer fields will be added to the metadata object.   &gt; ðŸ“˜ Standard customer fields mapping &gt; &gt; **No spaces allowed in field names**   &gt; Id, Name, Email, Phone, Birthdate, Source_id, Address_line_1, Address_line_2, Address_Postal_Code, Address_City, Address_State, Address_Country, Description, Metadata_name_1, Metadata_name_2  ## Update Customers using CSV  If you would like to update customer&#39;s data, you can do it using the CSV file with new data. However, remember to include a &#x60;source_id&#x60; in your CSV file to manage the update successfully.  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the &#x60;IN_PROGRESS&#x60; status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
    # @param file [File] File path.
    # @param [Hash] opts the optional parameters
    # @return [Array<(CustomersImportCsvCreateResponseBody, Integer, Hash)>] CustomersImportCsvCreateResponseBody data, response status code and response headers
    private def import_customers_using_csv_with_http_info(file, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CustomersApi.import_customers_using_csv ...'
      end
      # verify the required parameter 'file' is set
      if @api_client.config.client_side_validation && file.nil?
        fail ArgumentError, "Missing the required parameter 'file' when calling CustomersApi.import_customers_using_csv"
      end
      # resource path
      local_var_path = '/v1/customers/importCSV'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['multipart/form-data'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['file'] = file

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CustomersImportCsvCreateResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-App-Id', 'X-App-Token']

      new_options = opts.merge(
        :operation => :"CustomersApi.import_customers_using_csv",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CustomersApi#import_customers_using_csv\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Customer Activities
    # Retrieve customer activities.
    # @param customer_id [String] A Voucherify customer&#39;s &#x60;id&#x60; or source ID of the customer who performed the activities.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :limit A limit on the number of objects to be returned. Limit can range between 1 and 100 items.
    # @option opts [ParameterOrder] :order Sorts the results using one of the filtering options, where the dash &#x60;-&#x60; preceding a sorting option means sorting in a descending order.
    # @option opts [Time] :starting_after A cursor for use in pagination. &#x60;starting_after&#x60; is a date-time value that defines your place in the list based on &#x60;created_at&#x60; property from the activity object. For instance, if you make a list request and receive 100 objects, ending with an object created at &#x60;2020-05-24T13:43:09.024Z&#x60;, your subsequent call can include &#x60;starting_after&#x3D;2020-05-24T13:43:09.024Z&#x60; in order to fetch the next page of the list.
    # @option opts [String] :starting_after_id By applying this filter value, you will get events starting after an event with the given ID.
    # @option opts [ParameterCampaignType] :campaign_type Through this parameter you can control a type of campaign by which Voucherify will filter related customer&#39;s activity. API will return only records related to that given type. Allowed values: DISCOUNT_COUPONS, REFERRAL_PROGRAM, GIFT_VOUCHERS, PROMOTION, LOYALTY_PROGRAM
    # @option opts [String] :campaign_id By applying this parameter you request only events related to specific campaign identified by its ID.
    # @option opts [String] :product_id By applying this parameter you request only events related to specific product identified by its ID.
    # @option opts [Time] :start_date Timestamp representing the date and time which results must end on. Represented in ISO 8601 format.
    # @option opts [Time] :end_date Timestamp representing the date and time which results must end on. Represented in ISO 8601 format.
    # @return [CustomersActivitiesListResponseBody]
    def list_customer_activities(customer_id, opts = {})
      data, _status_code, _headers = list_customer_activities_with_http_info(customer_id, opts)
      data
    end

    # List Customer Activities
    # Retrieve customer activities.
    # @param customer_id [String] A Voucherify customer&#39;s &#x60;id&#x60; or source ID of the customer who performed the activities.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :limit A limit on the number of objects to be returned. Limit can range between 1 and 100 items.
    # @option opts [ParameterOrder] :order Sorts the results using one of the filtering options, where the dash &#x60;-&#x60; preceding a sorting option means sorting in a descending order.
    # @option opts [Time] :starting_after A cursor for use in pagination. &#x60;starting_after&#x60; is a date-time value that defines your place in the list based on &#x60;created_at&#x60; property from the activity object. For instance, if you make a list request and receive 100 objects, ending with an object created at &#x60;2020-05-24T13:43:09.024Z&#x60;, your subsequent call can include &#x60;starting_after&#x3D;2020-05-24T13:43:09.024Z&#x60; in order to fetch the next page of the list.
    # @option opts [String] :starting_after_id By applying this filter value, you will get events starting after an event with the given ID.
    # @option opts [ParameterCampaignType] :campaign_type Through this parameter you can control a type of campaign by which Voucherify will filter related customer&#39;s activity. API will return only records related to that given type. Allowed values: DISCOUNT_COUPONS, REFERRAL_PROGRAM, GIFT_VOUCHERS, PROMOTION, LOYALTY_PROGRAM
    # @option opts [String] :campaign_id By applying this parameter you request only events related to specific campaign identified by its ID.
    # @option opts [String] :product_id By applying this parameter you request only events related to specific product identified by its ID.
    # @option opts [Time] :start_date Timestamp representing the date and time which results must end on. Represented in ISO 8601 format.
    # @option opts [Time] :end_date Timestamp representing the date and time which results must end on. Represented in ISO 8601 format.
    # @return [Array<(CustomersActivitiesListResponseBody, Integer, Hash)>] CustomersActivitiesListResponseBody data, response status code and response headers
    private def list_customer_activities_with_http_info(customer_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CustomersApi.list_customer_activities ...'
      end
      # verify the required parameter 'customer_id' is set
      if @api_client.config.client_side_validation && customer_id.nil?
        fail ArgumentError, "Missing the required parameter 'customer_id' when calling CustomersApi.list_customer_activities"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 100
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling CustomersApi.list_customer_activities, must be smaller than or equal to 100.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] < 1
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling CustomersApi.list_customer_activities, must be greater than or equal to 1.'
      end

      # resource path
      local_var_path = '/v1/customers/{customerId}/activities'.sub('{' + 'customerId' + '}', CGI.escape(customer_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'order'] = opts[:'order'] if !opts[:'order'].nil?
      query_params[:'starting_after'] = opts[:'starting_after'] if !opts[:'starting_after'].nil?
      query_params[:'starting_after_id'] = opts[:'starting_after_id'] if !opts[:'starting_after_id'].nil?
      query_params[:'campaign_type'] = opts[:'campaign_type'] if !opts[:'campaign_type'].nil?
      query_params[:'campaign_id'] = opts[:'campaign_id'] if !opts[:'campaign_id'].nil?
      query_params[:'product_id'] = opts[:'product_id'] if !opts[:'product_id'].nil?
      query_params[:'start_date'] = opts[:'start_date'] if !opts[:'start_date'].nil?
      query_params[:'end_date'] = opts[:'end_date'] if !opts[:'end_date'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CustomersActivitiesListResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-App-Id', 'X-App-Token']

      new_options = opts.merge(
        :operation => :"CustomersApi.list_customer_activities",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CustomersApi#list_customer_activities\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Customer's Segments
    # Returns the list of segments IDs to which the customer belongs to.    If you pass a `customerId` which is not stored and recognized by Voucherify as an existing customer in the system, the response will generate a list of segments that the customer would potentialy qualify for if they were to become a customer tracked in the system.
    # @param customer_id [String] Unique identifier of a customer represented by an internal customer ID or customer source ID.
    # @param [Hash] opts the optional parameters
    # @return [CustomersSegmentsListResponseBody]
    def list_customer_segments(customer_id, opts = {})
      data, _status_code, _headers = list_customer_segments_with_http_info(customer_id, opts)
      data
    end

    # List Customer&#39;s Segments
    # Returns the list of segments IDs to which the customer belongs to.    If you pass a &#x60;customerId&#x60; which is not stored and recognized by Voucherify as an existing customer in the system, the response will generate a list of segments that the customer would potentialy qualify for if they were to become a customer tracked in the system.
    # @param customer_id [String] Unique identifier of a customer represented by an internal customer ID or customer source ID.
    # @param [Hash] opts the optional parameters
    # @return [Array<(CustomersSegmentsListResponseBody, Integer, Hash)>] CustomersSegmentsListResponseBody data, response status code and response headers
    private def list_customer_segments_with_http_info(customer_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CustomersApi.list_customer_segments ...'
      end
      # verify the required parameter 'customer_id' is set
      if @api_client.config.client_side_validation && customer_id.nil?
        fail ArgumentError, "Missing the required parameter 'customer_id' when calling CustomersApi.list_customer_segments"
      end
      # resource path
      local_var_path = '/v1/customers/{customerId}/segments'.sub('{' + 'customerId' + '}', CGI.escape(customer_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CustomersSegmentsListResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-App-Id', 'X-App-Token']

      new_options = opts.merge(
        :operation => :"CustomersApi.list_customer_segments",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CustomersApi#list_customer_segments\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Customers
    # Returns a list of customers.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :limit A limit on the number of objects to be returned. Limit can range between 1 and 100 items.
    # @option opts [Integer] :page Which page of results to return.
    # @option opts [String] :email Limit the customers to the ones that have this specific email address.
    # @option opts [String] :city Limit the customers to the ones that are located in the specified city.
    # @option opts [String] :name Filter customers by the name property.
    # @option opts [String] :segment_id Filter customers by the segment id.
    # @option opts [Time] :created_at_before Filter customers by date customer was created.
    # @option opts [Time] :created_at_after Filter customers by date customer was created.
    # @option opts [Time] :updated_at_before Filter customers by date customer was updated last time.
    # @option opts [Time] :updated_at_after Filter customers by date customer was updated last time.
    # @option opts [ParameterOrderListCustomers] :order This is a property that controls the sorting direction of the results. Sort the results using one of the filtering options, where the dash &#x60;-&#x60; preceding a sorting option means sorting in a descending order.
    # @option opts [Time] :starting_after A cursor for use in pagination. This is a date-time value that defines your place in the list based on &#x60;created_at&#x60; property from the customer object. For instance, if you make a list request and receive 100 objects, ending with an object created at &#x60;2020-05-24T13:43:09.024Z&#x60;, your subsequent call can include &#x60;starting_after&#x3D;2020-05-24T13:43:09.024Z&#x60; in order to fetch the next page of the list.  &lt;!-- title: Options --&gt; | **Option** | **Format** | **Sorting** | |:---|:---|:---| | Return customers **before** a specific creation date  | - set &#x60;starting_after&#x60; parameter to the breakpoint date | Sorting order is **descending**; the most recent dates first and least recent dates last. | | Return customers **after** a specific create or update date | - include the &#x60;order&#x60; parameter set to &#x60;created_at&#x60; or &#x60;updated_at&#x60;&lt;br&gt;- set &#x60;starting_after&#x60; to the breakpoint date | Sorting order is **ascending**; the least recent dates first and the most recent dates last. | 
    # @return [CustomersListResponseBody]
    def list_customers(opts = {})
      data, _status_code, _headers = list_customers_with_http_info(opts)
      data
    end

    # List Customers
    # Returns a list of customers.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :limit A limit on the number of objects to be returned. Limit can range between 1 and 100 items.
    # @option opts [Integer] :page Which page of results to return.
    # @option opts [String] :email Limit the customers to the ones that have this specific email address.
    # @option opts [String] :city Limit the customers to the ones that are located in the specified city.
    # @option opts [String] :name Filter customers by the name property.
    # @option opts [String] :segment_id Filter customers by the segment id.
    # @option opts [Time] :created_at_before Filter customers by date customer was created.
    # @option opts [Time] :created_at_after Filter customers by date customer was created.
    # @option opts [Time] :updated_at_before Filter customers by date customer was updated last time.
    # @option opts [Time] :updated_at_after Filter customers by date customer was updated last time.
    # @option opts [ParameterOrderListCustomers] :order This is a property that controls the sorting direction of the results. Sort the results using one of the filtering options, where the dash &#x60;-&#x60; preceding a sorting option means sorting in a descending order.
    # @option opts [Time] :starting_after A cursor for use in pagination. This is a date-time value that defines your place in the list based on &#x60;created_at&#x60; property from the customer object. For instance, if you make a list request and receive 100 objects, ending with an object created at &#x60;2020-05-24T13:43:09.024Z&#x60;, your subsequent call can include &#x60;starting_after&#x3D;2020-05-24T13:43:09.024Z&#x60; in order to fetch the next page of the list.  &lt;!-- title: Options --&gt; | **Option** | **Format** | **Sorting** | |:---|:---|:---| | Return customers **before** a specific creation date  | - set &#x60;starting_after&#x60; parameter to the breakpoint date | Sorting order is **descending**; the most recent dates first and least recent dates last. | | Return customers **after** a specific create or update date | - include the &#x60;order&#x60; parameter set to &#x60;created_at&#x60; or &#x60;updated_at&#x60;&lt;br&gt;- set &#x60;starting_after&#x60; to the breakpoint date | Sorting order is **ascending**; the least recent dates first and the most recent dates last. | 
    # @return [Array<(CustomersListResponseBody, Integer, Hash)>] CustomersListResponseBody data, response status code and response headers
    private def list_customers_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CustomersApi.list_customers ...'
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 100
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling CustomersApi.list_customers, must be smaller than or equal to 100.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] < 1
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling CustomersApi.list_customers, must be greater than or equal to 1.'
      end

      if @api_client.config.client_side_validation && !opts[:'page'].nil? && opts[:'page'] > 100
        fail ArgumentError, 'invalid value for "opts[:"page"]" when calling CustomersApi.list_customers, must be smaller than or equal to 100.'
      end

      # resource path
      local_var_path = '/v1/customers'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'page'] = opts[:'page'] if !opts[:'page'].nil?
      query_params[:'email'] = opts[:'email'] if !opts[:'email'].nil?
      query_params[:'city'] = opts[:'city'] if !opts[:'city'].nil?
      query_params[:'name'] = opts[:'name'] if !opts[:'name'].nil?
      query_params[:'segment_id'] = opts[:'segment_id'] if !opts[:'segment_id'].nil?
      query_params[:'created_at[before]'] = opts[:'created_at_before'] if !opts[:'created_at_before'].nil?
      query_params[:'created_at[after]'] = opts[:'created_at_after'] if !opts[:'created_at_after'].nil?
      query_params[:'updated_at[before]'] = opts[:'updated_at_before'] if !opts[:'updated_at_before'].nil?
      query_params[:'updated_at[after]'] = opts[:'updated_at_after'] if !opts[:'updated_at_after'].nil?
      query_params[:'order'] = opts[:'order'] if !opts[:'order'].nil?
      query_params[:'starting_after'] = opts[:'starting_after'] if !opts[:'starting_after'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CustomersListResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-App-Id', 'X-App-Token']

      new_options = opts.merge(
        :operation => :"CustomersApi.list_customers",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CustomersApi#list_customers\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Customer
    # Updates the specified customer by setting the values of the parameters passed in the request body. Any parameters not provided in the payload will be left unchanged.
    # @param customer_id [String] A Voucherify customer&#39;s &#x60;id&#x60; or &#x60;source_id&#x60;.
    # @param [Hash] opts the optional parameters
    # @option opts [CustomersUpdateRequestBody] :customers_update_request_body Specify the parameters to be updated.
    # @return [CustomersUpdateResponseBody]
    def update_customer(customer_id, opts = {})
      data, _status_code, _headers = update_customer_with_http_info(customer_id, opts)
      data
    end

    # Update Customer
    # Updates the specified customer by setting the values of the parameters passed in the request body. Any parameters not provided in the payload will be left unchanged.
    # @param customer_id [String] A Voucherify customer&#39;s &#x60;id&#x60; or &#x60;source_id&#x60;.
    # @param [Hash] opts the optional parameters
    # @option opts [CustomersUpdateRequestBody] :customers_update_request_body Specify the parameters to be updated.
    # @return [Array<(CustomersUpdateResponseBody, Integer, Hash)>] CustomersUpdateResponseBody data, response status code and response headers
    private def update_customer_with_http_info(customer_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CustomersApi.update_customer ...'
      end
      # verify the required parameter 'customer_id' is set
      if @api_client.config.client_side_validation && customer_id.nil?
        fail ArgumentError, "Missing the required parameter 'customer_id' when calling CustomersApi.update_customer"
      end
      # resource path
      local_var_path = '/v1/customers/{customerId}'.sub('{' + 'customerId' + '}', CGI.escape(customer_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'customers_update_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'CustomersUpdateResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-App-Id', 'X-App-Token']

      new_options = opts.merge(
        :operation => :"CustomersApi.update_customer",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CustomersApi#update_customer\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Customer's consents
    # Update marketing permissions for the specified customer.
    # @param customer_id [String] A Voucherify unique customer identifier or source ID.
    # @param [Hash] opts the optional parameters
    # @option opts [Object] :body Key-value pairs where the key is the consent identifier and value is a boolean that identifies if a customer has given the consent or not. To deny all consents use \&quot;unsubscribed\&quot; as a consent identifier and \&quot;true\&quot; as its value.    #### Examples  &lt;!-- title: \&quot;Request Body\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;json {     \&quot;cnst_aIdUulAh0SCsOCaS3005y7yS\&quot;: true,     \&quot;cnst_aIdUulAhwewqaS31213fdsfds\&quot;: false } &#x60;&#x60;&#x60;  Opt-out from all communication:  &lt;!-- title: \&quot;Request Body\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;json {     \&quot;unsubscribed\&quot;: true } &#x60;&#x60;&#x60;
    # @return [nil]
    def update_customers_consents(customer_id, opts = {})
      update_customers_consents_with_http_info(customer_id, opts)
      nil
    end

    # Update Customer&#39;s consents
    # Update marketing permissions for the specified customer.
    # @param customer_id [String] A Voucherify unique customer identifier or source ID.
    # @param [Hash] opts the optional parameters
    # @option opts [Object] :body Key-value pairs where the key is the consent identifier and value is a boolean that identifies if a customer has given the consent or not. To deny all consents use \&quot;unsubscribed\&quot; as a consent identifier and \&quot;true\&quot; as its value.    #### Examples  &lt;!-- title: \&quot;Request Body\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;json {     \&quot;cnst_aIdUulAh0SCsOCaS3005y7yS\&quot;: true,     \&quot;cnst_aIdUulAhwewqaS31213fdsfds\&quot;: false } &#x60;&#x60;&#x60;  Opt-out from all communication:  &lt;!-- title: \&quot;Request Body\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;json {     \&quot;unsubscribed\&quot;: true } &#x60;&#x60;&#x60;
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    private def update_customers_consents_with_http_info(customer_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CustomersApi.update_customers_consents ...'
      end
      # verify the required parameter 'customer_id' is set
      if @api_client.config.client_side_validation && customer_id.nil?
        fail ArgumentError, "Missing the required parameter 'customer_id' when calling CustomersApi.update_customers_consents"
      end
      # resource path
      local_var_path = '/v1/customers/{customerId}/consents'.sub('{' + 'customerId' + '}', CGI.escape(customer_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'body'])

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-App-Id', 'X-App-Token']

      new_options = opts.merge(
        :operation => :"CustomersApi.update_customers_consents",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CustomersApi#update_customers_consents\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Customers in bulk
    # Update several customers in one asynchronous operation.   In one request, it is possible to update a maximum of **100** records. In the response body, you get a unique async action identifier.    If a requested customer object is not found, then an **upsert** occurs. This is reflected in the [Get Async Action](ref:get-async-action) endpoint as follows:     ```json {     \"found\": false,     \"updated\": true } ```  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the `IN_PROGRESS` status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
    # @param [Hash] opts the optional parameters
    # @option opts [Array<CustomersUpdateInBulkRequestBody>] :customers_update_in_bulk_request_body Specify the customer fields that you would like to update in each customer object.
    # @return [CustomersUpdateInBulkResponseBody]
    def update_customers_in_bulk(opts = {})
      data, _status_code, _headers = update_customers_in_bulk_with_http_info(opts)
      data
    end

    # Update Customers in bulk
    # Update several customers in one asynchronous operation.   In one request, it is possible to update a maximum of **100** records. In the response body, you get a unique async action identifier.    If a requested customer object is not found, then an **upsert** occurs. This is reflected in the [Get Async Action](ref:get-async-action) endpoint as follows:     &#x60;&#x60;&#x60;json {     \&quot;found\&quot;: false,     \&quot;updated\&quot;: true } &#x60;&#x60;&#x60;  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the &#x60;IN_PROGRESS&#x60; status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
    # @param [Hash] opts the optional parameters
    # @option opts [Array<CustomersUpdateInBulkRequestBody>] :customers_update_in_bulk_request_body Specify the customer fields that you would like to update in each customer object.
    # @return [Array<(CustomersUpdateInBulkResponseBody, Integer, Hash)>] CustomersUpdateInBulkResponseBody data, response status code and response headers
    private def update_customers_in_bulk_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CustomersApi.update_customers_in_bulk ...'
      end
      # resource path
      local_var_path = '/v1/customers/bulk/async'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'customers_update_in_bulk_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'CustomersUpdateInBulkResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-App-Id', 'X-App-Token']

      new_options = opts.merge(
        :operation => :"CustomersApi.update_customers_in_bulk",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CustomersApi#update_customers_in_bulk\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Customers' Metadata in bulk
    # Update several customers metadata properties in one asynchronous operation.   In one request, it is possible to update a maximum of **100** records. In the response body, you get a unique async action identifier.    If a requested customer object is not found, then an **upsert** occurs. This is reflected in the [Get Async Action](ref:get-async-action) endpoint as follows:     ```json {     \"found\": false,     \"updated\": true } ```  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the `IN_PROGRESS` status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
    # @param [Hash] opts the optional parameters
    # @option opts [CustomersMetadataUpdateInBulkRequestBody] :customers_metadata_update_in_bulk_request_body List the &#x60;source_ids&#x60; of the customer&#39;s you would like to update along with the metadata key value pairs.
    # @return [CustomersMetadataUpdateInBulkResponseBody]
    def update_customers_metadata_in_bulk(opts = {})
      data, _status_code, _headers = update_customers_metadata_in_bulk_with_http_info(opts)
      data
    end

    # Update Customers&#39; Metadata in bulk
    # Update several customers metadata properties in one asynchronous operation.   In one request, it is possible to update a maximum of **100** records. In the response body, you get a unique async action identifier.    If a requested customer object is not found, then an **upsert** occurs. This is reflected in the [Get Async Action](ref:get-async-action) endpoint as follows:     &#x60;&#x60;&#x60;json {     \&quot;found\&quot;: false,     \&quot;updated\&quot;: true } &#x60;&#x60;&#x60;  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the &#x60;IN_PROGRESS&#x60; status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
    # @param [Hash] opts the optional parameters
    # @option opts [CustomersMetadataUpdateInBulkRequestBody] :customers_metadata_update_in_bulk_request_body List the &#x60;source_ids&#x60; of the customer&#39;s you would like to update along with the metadata key value pairs.
    # @return [Array<(CustomersMetadataUpdateInBulkResponseBody, Integer, Hash)>] CustomersMetadataUpdateInBulkResponseBody data, response status code and response headers
    private def update_customers_metadata_in_bulk_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: CustomersApi.update_customers_metadata_in_bulk ...'
      end
      # resource path
      local_var_path = '/v1/customers/metadata/async'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'customers_metadata_update_in_bulk_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'CustomersMetadataUpdateInBulkResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-App-Id', 'X-App-Token']

      new_options = opts.merge(
        :operation => :"CustomersApi.update_customers_metadata_in_bulk",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: CustomersApi#update_customers_metadata_in_bulk\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
